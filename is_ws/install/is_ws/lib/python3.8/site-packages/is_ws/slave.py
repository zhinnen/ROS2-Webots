import rclpy
from webots_ros2_core.webots_node import WebotsNode
from std_msgs.msg import Float64
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Imu
from sensor_msgs.msg import Image
from sensor_msgs.msg import Range

import math
import time


DEVICE_CONFIG = { 'camera1' : 
{'topic_name' : 'camera', 'timestep': 16} }

class service_node_vel(WebotsNode):
    def __init__(self, args):
        super().__init__("slave_node", args)

        #enable sensors
        self.timestep = 64

        #sensor section
        self.sensorTimer = self.create_timer(
            0.001 * self.timestep, self.sensor_callback)
        
        self.rightDistance_sensor = self.robot.getDevice("right_ds")
        self.rightDistance_sensor.enable(self.timestep)
        self.sensorPublisher_rightDistance = self.create_publisher(Range, 'right_IR', 1)

        self.leftDistance_sensor = self.robot.getDevice("left_ds")
        self.leftDistance_sensor.enable(self.timestep)
        self.sensorPublisher_leftDistance = self.create_publisher(Range, 'left_IR', 1)

        self.frontDistance_sensor = self.robot.getDevice("front_ds")
        self.frontDistance_sensor.enable(self.timestep)
        self.sensorPublisher_frontDistance = self.create_publisher(Range, 'front_IR', 1)

        self.rightPosition_sensor = self.robot.getDevice('right wheel sensor')
        self.rightPosition_sensor.enable(self.timestep)
        self.sensorPublisher_rightPosition = self.create_publisher(Float64, 'right_PR', 1)

        self.leftPosition_sensor = self.robot.getDevice('left wheel sensor')
        self.leftPosition_sensor.enable(self.timestep)
        self.sensorPublisher_leftPosition = self.create_publisher(Float64, 'left_PR', 1)

        #camera
        self.start_device_manager(DEVICE_CONFIG)
        
        self.get_logger().info('Sensor enabled')

        #wheels section
        self.leftMotor = self.robot.getDevice('left wheel motor')
        self.leftMotor.setPosition(float('inf'))
        self.leftMotor.setVelocity(0)

        self.rightMotor = self.robot.getDevice('right wheel motor')
        self.rightMotor.setPosition(float('inf'))
        self.rightMotor.setVelocity(0)

        self.motorMaxSpeed = self.leftMotor.getMaxVelocity()

        self.cmdVelSubscriber = self.create_subscription(Twist, 'cmd_vel', self.cmdVel_callback, 1)

        #enable imu
        self.imu = self.robot.getDevice('inertial unit')
        self.imu.enable(self.timestep)
        self.sensorPulisher_IMU = self.create_publisher(Float64, 'IMU_IR', 1)

    def cmdVel_callback(self, msg):
        wheelGap = 2.28
        wheelRadius = 0.8

        leftSpeed = ((2.0 * msg.linear.x - msg.angular.z *
                       wheelGap) / (2.0 * wheelRadius))
        rightSpeed = ((2.0 * msg.linear.x + msg.angular.z *
                        wheelGap) / (2.0 * wheelRadius))
        leftSpeed = min(self.motorMaxSpeed, max(-self.motorMaxSpeed, leftSpeed))
        rightSpeed = min(self.motorMaxSpeed, max(-self.motorMaxSpeed, rightSpeed))

        self.leftMotor.setVelocity(leftSpeed)
        self.rightMotor.setVelocity(rightSpeed)

    def sensor_callback(self):
        msg_rightD = Range()
        self.rightDistance_sensor.enable(self.timestep)
        msg_rightD.range = self.rightDistance_sensor.getValue()
        self.get_logger().info("how often slave")
        self.get_logger().info(str(self.rightDistance_sensor.getValue()))
        self.sensorPublisher_rightDistance.publish(msg_rightD)

        msg_leftD = Range()
        self.leftDistance_sensor.enable(self.timestep)
        msg_leftD.range = self.leftDistance_sensor.getValue()
        self.sensorPublisher_leftDistance.publish(msg_leftD)

        msg_frontD = Range()
        self.frontDistance_sensor.enable(self.timestep)
        msg_frontD.range = self.frontDistance_sensor.getValue()
        self.sensorPublisher_frontDistance.publish(msg_frontD)

        msg_rightP = Float64()
        self.rightPosition_sensor.enable(self.timestep)
        msg_rightP.data = self.rightPosition_sensor.getValue()
        self.sensorPublisher_rightPosition.publish(msg_rightP)

        msg_leftP = Float64()
        self.leftPosition_sensor.enable(self.timestep)
        msg_leftP.data = self.leftPosition_sensor.getValue()
        self.sensorPublisher_leftPosition.publish(msg_leftP)
            

def main(args=None):
    rclpy.init(args=args)
    client_vel = service_node_vel(args=args)
    rclpy.spin(client_vel)

    client_vel.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
                

            

