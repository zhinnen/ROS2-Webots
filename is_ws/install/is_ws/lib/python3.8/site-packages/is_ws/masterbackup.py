import rclpy
import time
import math
from rclpy.node import Node
from sensor_msgs.msg import Image
from sensor_msgs.msg import Imu
from std_msgs.msg import Float64
from geometry_msgs.msg import Twist
import numpy as np

class NavigateCells(Node):
    def __init__(self):
        super().__init__('NavigateCells_cmdvel')
        #subsribers for sensors
        self.subs_right_ir = self.create_subscription(Float64, 'right_IR', self.rightIR_cb, 1)
        self.subs_left_ir = self.create_subscription(Float64, 'left_IR', self.leftIR_cb, 1)
        self.subs_front_ir = self.create_subscription(Float64, 'front_IR', self.frontIR_cb, 1)
        self.subs_right_pr = self.create_subscription(Float64, 'right_PR', self.rightPR_cb, 1)
        self.subs_left_pr = self.create_subscription(Float64, 'left_PR', self.leftPR_cb, 1)
        self.subs_IMU = self.create_subscription(Float64, 'IMU_IR', self.IMUIR_cb, 1)
        #publish cmd vel
        self.pubs_cmdvel = self.create_publisher(Twist, 'cmd_vel', 1)

        #vehicle parameters
        self.speed = 4
        self.angle_correction = 0.5

        #camera
        #self.camera_subsciber = self.create_subscription(Image, 'camera/image_raw', self.Image_processing_callback, 1)
        #self.processedImage_publish = self.create_publisher(Image, 'camera/processed_unage', 1)

        #init parameters
        self.rds, self.lds, self.fds = 0, 0, 0
        self.lps, self.rps = 0, 0
        self.imu = 0.0
        self.cmd = Twist()
        self.current_time = time.time()
        self.start_time = self.current_time
        self.cell_list = []
        self.currentCell = 0
        self.compass = ["North", "East", "South", "West"]
        self.n = 0
        self.count = 0
        self.get_logger().info(str(self.fds))

    def rightIR_cb(self, msg):
        self.rds = msg.data
        self.NavigatingModule()
    
    def leftIR_cb(self, msg):
        self.lds = msg.data
    
    def frontIR_cb(self, msg):
        self.fds = msg.data

    def rightPR_cb(self, msg):
        self.rps = msg.data

    def leftPR_cb(self, msg):
        self.ls = msg.data

    def IMUIR_cb(self, msg):
        self.imu = msg.data

    def NavigatingModule(self):
        def getIMU():
            yaw = self.imu.orientation.y
            yaw_degree=((yaw * 180)/(math.pi))
            final_degree = abs(yaw_degree - 180)
            return final_degree

        def setSpeed(new_speed):
            self.cmd.linear.x = new_speed
            self.pubs_cmdvel.publish(self.cmd)


        def getDirection():
            tempDegree = getIMU()
            if(tempDegree > 330 or tempDegree < 30):
                return self.compass[0]
            elif(tempDegree > 60 and tempDegree < 120):
                return self.compass[1]
            elif(tempDegree > 150 and tempDegree < 210):
                return self.compass[2]
            elif(tempDegree < 300 and tempDegree > 240):
                return self.compass[3]
            else:
                return '?'

        def CellsTraveled():
            if self.currentCell not in self.cell_list:
                self.cell_list.append(self.currentCell)
                self.count = self.count + 1
            else:
                print(self.cell_list)
            return self.count
                
        def turn(degree):
            while (True):
                self.cmd.linear.x = 2.0
                #self.cmd.angular.z = self.angle_correction
                self.pubs_cmdvel.publish(self.cmd)
                #if(degree-2 < getIMU() < degree+1):
                inch_fds = (self.fds/0.0254)
                if(inch_fds < 15.0):
                    self.cmd.linear.x = 0.0
                    self.cmd.angular.z = 0.0
                    self.pubs_cmdvel.publish(self.cmd)
                    break
            print("OUT")

        def getCoordinates():
            self.get_logger().info(str(self.fds))
            turn(140)
            string = "Red"
            red = self.findObject(string)
            print(red)
            turn(45)
            string = "Yellow"
            yellow = self.findObject(string)
            print(yellow)
            turn(325)
            string = "Green"
            green = self.findObject(string)
            print(green)
            print(green,yellow,red)
            x, y = triLat(20,20,yellow,-20,20,green,20,-20,red)
            print(x,y)
            return(x,y)
        
        def triLat(x1,y1,r1,x2,y2,r2,x3,y3,r3):
            A = 2*x2 - 2*x1
            B = 2*y2 - 2*y1
            C = r1**2 - r2**2 - x1**2 + x2**2 - y1**2 + y2**2
            D = 2*x3 - 2*x2
            E = 2*y3 - 2*y2
            F = r2**2 - r3**2 - x2**2 + x3**2 - y2**2 + y3**2
            x = (C*E - F*B) / (E*A - B*D)
            y = (C*D - A*F) / (B*D - A*E)
            return x,y
                
        def currCell(self,x,y):
            if(x < -10 and y > 10):
                self.currentCell = 1
            if(x < 0 and y > 10):
                self.currentCell = 2
            if(x > 0 and y > 10):
                self.currentCell = 3
            if(x > 10 and y > 10):
                self.currentCell = 4
            if(x < -10 and y > 0):
                self.currentCell = 5
            if(x < 0 and y > 0):
                self.currentCell = 6
            if(x > 0 and x < 10 and y > 0):
                self.currentCell = 7
            if(x > 10 and y > 0):
                self.currentCell = 8
            if(x < -10 and y < 0 and y > -10):
                self.currentCell = 9
            if(x < 0 and x > -10 and y < 0 and y > -10):
                self.currentCell = 10
            if(x > 0 and x < 10 and y < 0 and y > -10):
                self.currentCell = 11
            if(x > 10 and y < 0 and y > -10):
                self.currentCell = 12
            if(x < -10  and y < -10):
                self.currentCell = 13
            if(x < 0 and x > -10 and y < -10):
                self.currentCell = 14
            if(x > 0 and x < 10 and y < -10):
                self.currentCell = 15
            if(x > 10 and y < -10):
                self.currentCell = 16
            return self.currentCell
            
        def checkWalls(currentCell, count):
            while (True):
                inch_fds = (self.fds/0.0254)
                inch_rds = (self.rds/0.0254)
                inch_lds = (self.lds/0.0254)

                self.getDirection()
                if(getIMU() > 268 and getIMU() < 272 and inch_fds > 10):
                    self.setSpeed(0)
                    break
                elif(getIMU() > 178 and getIMU() < 182 and inch_fds > 10):
                    self.setSpeed(0)
                    break
                elif(getIMU() > 88 and getIMU() < 92 and inch_fds > 10):
                    self.setSpeed(0)
                    break
                elif(getIMU() > 357 and inch_fds > 10):
                    self.setSpeed(0)
                    break
                else:
                    self.cmd.angular.z = self.angle_correction  
                        
        def findObject(self, string):
            self.cmd.linear.x = 0.1
            self.cmd.angular.z = self.angle_correction
            red = 0
            yellow = 0
            green = 0
            if(string == "Yellow"):
                while (True):
                    if(len(self.camera.getRecognitionObjects()) > 0):
                        object = camera.getRecognitionObjects()[0]
                        ID = object.get_id() 
                        if(abs(object.get_position()[0]) < 0.02 and object.get_id() == ID):
                            inch_fds = (self.fds/0.0254)
                            yellow = inch_fds
                            print("Yellow Object found", yellow)
                            return yellow
                            
            elif(string == "Red"):
                while (True):
                    if(len(self.camera.getRecognitionObjects()) > 0):
                        object = camera.getRecognitionObjects()[0]
                        ID = object.get_id() 
                        if(abs(object.get_position()[0]) < 0.02 and object.get_id() == ID):
                            inch_fds = (self.fds/0.0254)
                            red = inch_fds
                            print("Red Object found", red)
                            return red

            elif(string == "Green"):
                while (True):
                    if(len(self.camera.getRecognitionObjects()) > 0):
                        object = camera.getRecognitionObjects()[0]
                        ID = object.get_id() 
                        if(abs(object.get_position()[0]) < 0.02 and object.get_id() == ID):
                            inch_fds = (self.fds/0.0254)
                            green = inch_fds
                            print("Green Object found", green)
                            return green
                
        def drive(self, x, y):
            inch_fds = (self.fds/0.0254)
            start_position = inch_fds
                
            while (True):                
                inch_fds = (self.fds/0.0254)
                inch_rds = (self.rds/0.0254)
                inch_lds = (self.lds/0.0254)

                distance_trav = start_position - inch_fds
                print(distance_trav)
                
                self.setSpeed(4)    
                direction = self.getDirection()
                if(direction == "North"):
                    if(distance_trav > 10):
                            self.setSpeed(0)
                            y = y + distance_trav
                            print("Robot pose is: ", "X: ", x, "Y: ", y, "CurrentCell: ", self.currentCell, "Angle: ", getIMU())
                            return x, y
                elif(direction == "East"):
                    if(distance_trav > 10):
                            self.setSpeed(0)
                            x = x + distance_trav
                            print("Robot pose is: ", "X: ", x, "Y: ", y, "CurrentCell: ", self.currentCell, "Angle: ", getIMU())
                            return x, y
                elif(direction == "West"):
                    if(distance_trav > 10):
                            self.setSpeed(0)
                            x = x - distance_trav
                            print("Robot pose is X:", x, "Y:", y, "CurrentCell:", self.currentCell, "Angle:", getIMU())
                            return x, y
                elif(direction == "South"):
                    if(distance_trav > 10):
                            self.setSpeed(0)
                            y = y - distance_trav
                            print("Robot pose is: ", "X: ", x, "Y: ", y, "CurrentCell: ", self.currentCell, "Angle: ", getIMU())
                            return x, y

        def checkPath(self):
            while(True):
                inch_fds = (self.fds/0.0254)
                checkWalls(self.currentCell, self.count)
                direction = self.getDirection()
                if(direction == "North"):
                    originalCell = self.currentCell
                    self.currentCell = self.currentCell - 4
                    new_count = self.CellsTraveled()
                    if(self.count == new_count):
                        turn(270)
                        self.currentCell = originalCell
                    else:
                        return self.currentCell, new_count
                elif(direction == "West"):
                    originalCell = self.currentCell
                    self.currentCell = self.currentCell - 1
                    new_count = self.CellsTraveled()
                    if(self.count == new_count):
                        turn(180)
                        self.currentCell = originalCell
                    else:
                        return self.currentCell, new_count
                elif(direction == "South"):
                    originalCell = self.currentCell
                    self.currentCell = self.currentCell + 4
                    new_count = self.CellsTraveled()
                    if(self.count == new_count):
                        turn(90)
                        self.currentCell = originalCell
                    else:
                        return self.currentCell, new_count
                elif(direction == "East"):
                    originalCell = self.currentCell
                    self.currentCell = self.currentCell + 1
                    new_count = self.CellsTraveled()
                    if(self.count == new_count):
                        turn(360)
                        self.currentCell = originalCell
                    else:
                        return self.currentCell, new_count
                

        while(True):
            if(self.n == 0):
                x, y = getCoordinates()
                self.currentCell = self.currCell(x,y)
                self.n = self.n + 1
            else:
                self.count = self.CellsTraveled()
                if(self.count == 16):
                    self.setSpeed(0)
                    break
                else:
                    print("COUNT IS: ", self.count)
                    self.currentCell, self.count = self.checkPath()
                    x, y = self.drive(x, y)
            
def main(args=None):
    rclpy.init(args=args)
    
    NC = NavigateCells()
    rclpy.spin(NC)

    NC.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()